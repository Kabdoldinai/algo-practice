package org.practice.arrays;

public class CanPlaceFlowers {

    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        if (n == 0) return true;

        for (int i = 0; i < flowerbed.length; i++) {
            boolean leftEmpty = (i == 0) || (flowerbed[i - 1] == 0);
            boolean rightEmpty = (i == flowerbed.length - 1) || (flowerbed[i + 1] == 0);

            if (flowerbed[i] == 0 && leftEmpty && rightEmpty) {
                flowerbed[i] = 1;
                n--;

                if (n == 0) return true;
            }
        }

        return n == 0;
    }


}


/*
Задача:
Нужно определить, можно ли посадить n цветов в клумбу (массив), соблюдая правило:
никакие два цветка не должны быть посажены рядом друг с другом.

Подход:
Я использовала один проход по массиву (O(n)), чтобы найти подходящие места для посадки цветов.
Основная идея: проверить для каждой позиции, можно ли там посадить цветок, и если да — посадить (пометив её 1) и уменьшить n.

Логика проверки:

Сначала я добавила оптимизацию:
Если n == 0, я сразу возвращаю true, потому что ничего сажать не нужно.

Для каждой позиции i я проверяю три условия:

Текущая клетка свободна (flowerbed[i] == 0)

Левая клетка свободна — либо i == 0, либо flowerbed[i - 1] == 0

Правая клетка свободна — либо i == flowerbed.length - 1, либо flowerbed[i + 1] == 0

Почему это безопасно:

Я использую short-circuit логику с ||, чтобы избежать выхода за границы массива.

Например, если i == 0, то левая сторона считается свободной по определению, и flowerbed[i - 1] даже не вычисляется — это предотвращает IndexOutOfBoundsException.

Если все условия соблюдены, я "сажаю цветок" — устанавливаю flowerbed[i] = 1, уменьшаю n, и если n стал равен 0 — сразу возвращаю true.

Если после прохода n > 0, то цветов недостаточно — возвращаю false.

Преимущества подхода:

Работает за линейное время, O(n)

Использует минимум памяти — только исходный массив

Защищён от ошибок выхода за границы

Включает ранний выход, что ускоряет выполнение в типичных случаях

 */